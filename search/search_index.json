{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PEH Validation Library","text":"<p>PEH Validation Library is a Python package designed to simplify and standardize the validation of data within DataFrames. It provides a flexible and extensible framework for defining validation rules, ensuring that your data meets quality and consistency requirements before further processing or analysis.</p> <p>Key features include customizable validation checks and detailed error reporting. This library is ideal for  enforcing data integrity, automating quality checks, and reducing manual validation effort in their data pipelines.</p> <p>For API documentation, please see the API Reference.</p>"},{"location":"api/","title":"API Reference","text":"<p>Enums used in the validation library. These enums define various constants used throughout the library for error levels, validation types, and check cases.</p> <p>config_input must use the following naming conventions.</p>"},{"location":"api/#peh_validation_library.validator.validator.Validator","title":"Validator","text":"<p>Validator class for validating DataFrames against a defined schema.</p> Source code in <code>src/peh_validation_library/validator/validator.py</code> <pre><code>class Validator:\n    \"\"\"Validator class for validating DataFrames against a defined schema.\"\"\"\n\n    error_collector = ErrorCollector()\n\n    @classmethod\n    def config_from_mapping(\n        cls,\n        config: Mapping[str, str | Sequence | Mapping],\n        collect_exceptions: bool = True,\n        logger: logging.Logger = logger,\n    ) -&gt; Validator:\n        \"\"\"Creates a DFSchema from a configuration mapping.\n\n        Args:\n            config (Mapping[str, str | Sequence | Mapping]): Configuration\n                mapping for the DataFrame schema.\n            collect_exceptions (bool, optional): Whether to collect exceptions\n                during the schema creation. Defaults to True.\n            logger (logging.Logger, optional): Logger instance for logging.\n                Defaults to the module logger.\n\n        Examples:\n            The command is either a user-defined function or a string that\n            maps to a function that will be used to validate the DataFrame.\n\n            The following commands are available:\n\n                'is_equal_to',\n                'is_equal_to_or_both_missing',\n                'is_greater_than_or_equal_to',\n                'is_greater_than',\n                'is_less_than_or_equal_to',\n                'is_less_than',\n                'is_not_equal_to',\n                'is_not_equal_to_and_not_both_missing',\n                'is_unique',\n                'is_duplicated',\n                'is_in',\n                'is_null',\n                'is_not_null'\n\n            &gt;&gt;&gt; config_input = {\n                    \"name\": \"example_schema\",\n                    \"columns\": [\n                        {\n                            \"id\": \"column1\",\n                            \"data_type\": \"integer\",\n                            \"nullable\": False,\n                            \"unique\": True,\n                            \"required\": True,\n                            \"checks\": [\n                                {\n                                    \"command\": \"is_equal_to\",\n                                    \"subject\": [\"column2\"]\n                                }\n                            ]\n                        },\n                        {\n                            \"id\": \"column2\",\n                            \"data_type\": \"varchar\",\n                            \"nullable\": True,\n                            \"unique\": False,\n                            \"required\": False,\n                            \"checks\": [\n                                {\n                                    'check_case': 'condition',\n                                    'expressions': [\n                                        {\n                                            'command': 'is_in',\n                                            'arg_values': ['a', 'b', 'c']\n                                        },\n                                        {\n                                            'command': 'is_equal_to',\n                                            'subject': ['column1'],\n                                            'arg_values': [1]\n                                        }\n                                    ]\n                                }\n                            ],\n                        }\n                    \"ids\": [\"column1\"],\n                    \"metadata\": {\"description\": \"Example DataFrame schema\"},\n                    \"checks\": [\n                        {\n                            'name': 'example_check',\n                            'error_level': 'warning',\n                            'error_msg': 'This is an example check',\n                            'command': 'is_in',\n                            'subject': ['column1', 'column2'],\n                            'arg_values': [1, 2]\n                        }\n                    ]\n                }\n\n        Returns:\n            Validator: An instance of the Validator class with the schema\n                created from the provided configuration mapping.\n\n        Raises:\n            Exception: If an error occurs while reading the configuration\n                or creating the schema, and collect_exceptions is False.\n\n        \"\"\"\n        validator = cls()\n        try:\n            validator.df_schema = get_df_schema(config)\n\n        except Exception as err:\n            msg = f'Error reading inputs: {err}'\n            logger.error(msg)\n\n            if not collect_exceptions:\n                raise err\n\n            error_traceback = traceback.format_exc()\n            validator.error_collector.add_errors(\n                ExceptionSchema(\n                    error_type=type(err).__name__,\n                    error_message=str(err),\n                    error_level='critical',\n                    error_traceback=error_traceback,\n                    error_context='Validator.config_from_mapping',\n                    error_source=__name__,\n                )\n            )\n\n        logger.info('DFSchema created successfully')\n        return validator\n\n    def convert_mapping_to_dataframe(\n        self,\n        dataframe: Mapping[str, list] | pl.DataFrame,\n        collect_exceptions: bool = True,\n        logger: logging.Logger = logger,\n    ) -&gt; pl.DataFrame:\n        logger.info('Reading DataFrame from mapping')\n        try:\n            return read_dataframe(dataframe)\n        except Exception as err:\n            msg = f'Error converting dataframe: {err}'\n            logger.error(msg)\n\n            if not collect_exceptions:\n                raise err\n\n            error_traceback = traceback.format_exc()\n            self.error_collector.add_errors(\n                ExceptionSchema(\n                    error_type=type(err).__name__,\n                    error_message=str(err),\n                    error_level='critical',\n                    error_traceback=error_traceback,\n                    error_context='Validator.convert_mapping_to_dataframe',\n                    error_source=__name__,\n                )\n            )\n\n    def validate(\n        self,\n        dataframe: Mapping[str, list] | pl.DataFrame,\n        lazy_validation: bool = True,\n        collect_exceptions: bool = True,\n        logger: logging.Logger = logger,\n    ) -&gt; None:\n        \"\"\"Validates a DataFrame against the defined schema.\n\n        Args:\n            dataframe (Mapping[str, list] | pl.DataFrame): The input data\n                as a mapping or a Polars DataFrame.\n            lazy_validation (bool, optional): Whether to perform lazy validation.\n                Defaults to True.\n            collect_exceptions (bool, optional): Whether to collect exceptions\n                during validation. Defaults to True.\n            logger (logging.Logger, optional): Logger instance for logging.\n                Defaults to the module logger.\n\n        Raises:\n            Exception: If an error occurs during validation and\n                collect_exceptions is False.\n\n        \"\"\"  # noqa: E501\n        logger.info('Starting DataFrame validation')\n        if isinstance(dataframe, Mapping):\n            dataframe = self.convert_mapping_to_dataframe(\n                dataframe=dataframe,\n                collect_exceptions=collect_exceptions,\n                logger=logger,\n            )\n\n        try:\n            logger.info(f'Building DataFrame schema {self.df_schema.name =}')\n            df_schema = self.df_schema.build()\n        except Exception as err:\n            msg = f'Error building dataframe schema: {err}'\n            logger.error(msg)\n\n            if not collect_exceptions:\n                raise err\n\n            error_traceback = traceback.format_exc()\n            self.error_collector.add_errors(\n                ExceptionSchema(\n                    error_type=type(err).__name__,\n                    error_message=str(err),\n                    error_level='critical',\n                    error_traceback=error_traceback,\n                    error_context='Validator.validate',\n                    error_source=__name__,\n                )\n            )\n            return\n\n        try:\n            logger.info('Casting DataFrame Types')\n            dataframe = dataframe.cast({\n                col.id: validation_type_mapper[col.data_type]\n                for col in self.df_schema.columns\n                if col.id in dataframe.columns\n            })\n\n        except Exception as err:\n            msg = f'Error casting dataframe types: {err}'\n            logger.error(msg)\n\n            if not collect_exceptions:\n                raise err\n\n            error_traceback = traceback.format_exc()\n            self.error_collector.add_errors(\n                ExceptionSchema(\n                    error_type=type(err).__name__,\n                    error_message=str(err),\n                    error_level='critical',\n                    error_traceback=error_traceback,\n                    error_context='Validator.validate',\n                    error_source=__name__,\n                )\n            )\n            return\n\n        try:\n            logger.info('Starting DataFrame validation')\n            dataframe.pipe(df_schema.validate, lazy=lazy_validation)\n\n        except (pa.errors.SchemaErrors, pa.errors.SchemaError) as err:\n            if not collect_exceptions:\n                raise err\n\n            logger.info('Collecting validation errors')\n            self.error_collector.add_errors(err)\n\n        # Pandera not implemented for polars some lazy validation.\n        # Run in again in eager mode to catch the error.\n        # This is a workaround for the issue.\n        except NotImplementedError:\n            try:\n                logger.warning('Trying eager validation')\n                dataframe.pipe(df_schema.validate)\n\n            except pa.errors.SchemaError as err:\n                if not collect_exceptions:\n                    raise err\n\n                logger.info('Collecting eager validation errors')\n                self.error_collector.add_errors(err)\n\n        except Exception as err:\n            msg = f'Error validating dataframe: {err}'\n            logger.error(msg)\n\n            if not collect_exceptions:\n                raise err\n\n            error_traceback = traceback.format_exc()\n            self.error_collector.add_errors(\n                ExceptionSchema(\n                    error_type=type(err).__name__,\n                    error_message=str(err),\n                    error_level='critical',\n                    error_traceback=error_traceback,\n                    error_context='Validator.validate',\n                    error_source=__name__,\n                )\n            )\n\n        logger.info('DataFrame validation completed')\n</code></pre>"},{"location":"api/#peh_validation_library.validator.validator.Validator.config_from_mapping","title":"config_from_mapping  <code>classmethod</code>","text":"<pre><code>config_from_mapping(\n    config: Mapping[str, str | Sequence | Mapping],\n    collect_exceptions: bool = True,\n    logger: logging.Logger = logger,\n) -&gt; Validator\n</code></pre> <p>Creates a DFSchema from a configuration mapping.</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, str | Sequence | Mapping]</code> <p>Configuration mapping for the DataFrame schema.</p> required <code>bool</code> <p>Whether to collect exceptions during the schema creation. Defaults to True.</p> <code>True</code> <code>logging.Logger</code> <p>Logger instance for logging. Defaults to the module logger.</p> <code>logger</code> <p>Examples:</p> <p>The command is either a user-defined function or a string that maps to a function that will be used to validate the DataFrame.</p> <p>The following commands are available:</p> <pre><code>'is_equal_to',\n'is_equal_to_or_both_missing',\n'is_greater_than_or_equal_to',\n'is_greater_than',\n'is_less_than_or_equal_to',\n'is_less_than',\n'is_not_equal_to',\n'is_not_equal_to_and_not_both_missing',\n'is_unique',\n'is_duplicated',\n'is_in',\n'is_null',\n'is_not_null'\n</code></pre> <pre><code>&gt;&gt;&gt; config_input = {\n        \"name\": \"example_schema\",\n        \"columns\": [\n            {\n                \"id\": \"column1\",\n                \"data_type\": \"integer\",\n                \"nullable\": False,\n                \"unique\": True,\n                \"required\": True,\n                \"checks\": [\n                    {\n                        \"command\": \"is_equal_to\",\n                        \"subject\": [\"column2\"]\n                    }\n                ]\n            },\n            {\n                \"id\": \"column2\",\n                \"data_type\": \"varchar\",\n                \"nullable\": True,\n                \"unique\": False,\n                \"required\": False,\n                \"checks\": [\n                    {\n                        'check_case': 'condition',\n                        'expressions': [\n                            {\n                                'command': 'is_in',\n                                'arg_values': ['a', 'b', 'c']\n                            },\n                            {\n                                'command': 'is_equal_to',\n                                'subject': ['column1'],\n                                'arg_values': [1]\n                            }\n                        ]\n                    }\n                ],\n            }\n        \"ids\": [\"column1\"],\n        \"metadata\": {\"description\": \"Example DataFrame schema\"},\n        \"checks\": [\n            {\n                'name': 'example_check',\n                'error_level': 'warning',\n                'error_msg': 'This is an example check',\n                'command': 'is_in',\n                'subject': ['column1', 'column2'],\n                'arg_values': [1, 2]\n            }\n        ]\n    }\n</code></pre> <p>Returns:</p> Name Type Description <code>Validator</code> <code>Validator</code> <p>An instance of the Validator class with the schema created from the provided configuration mapping.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an error occurs while reading the configuration or creating the schema, and collect_exceptions is False.</p> Source code in <code>src/peh_validation_library/validator/validator.py</code> <pre><code>@classmethod\ndef config_from_mapping(\n    cls,\n    config: Mapping[str, str | Sequence | Mapping],\n    collect_exceptions: bool = True,\n    logger: logging.Logger = logger,\n) -&gt; Validator:\n    \"\"\"Creates a DFSchema from a configuration mapping.\n\n    Args:\n        config (Mapping[str, str | Sequence | Mapping]): Configuration\n            mapping for the DataFrame schema.\n        collect_exceptions (bool, optional): Whether to collect exceptions\n            during the schema creation. Defaults to True.\n        logger (logging.Logger, optional): Logger instance for logging.\n            Defaults to the module logger.\n\n    Examples:\n        The command is either a user-defined function or a string that\n        maps to a function that will be used to validate the DataFrame.\n\n        The following commands are available:\n\n            'is_equal_to',\n            'is_equal_to_or_both_missing',\n            'is_greater_than_or_equal_to',\n            'is_greater_than',\n            'is_less_than_or_equal_to',\n            'is_less_than',\n            'is_not_equal_to',\n            'is_not_equal_to_and_not_both_missing',\n            'is_unique',\n            'is_duplicated',\n            'is_in',\n            'is_null',\n            'is_not_null'\n\n        &gt;&gt;&gt; config_input = {\n                \"name\": \"example_schema\",\n                \"columns\": [\n                    {\n                        \"id\": \"column1\",\n                        \"data_type\": \"integer\",\n                        \"nullable\": False,\n                        \"unique\": True,\n                        \"required\": True,\n                        \"checks\": [\n                            {\n                                \"command\": \"is_equal_to\",\n                                \"subject\": [\"column2\"]\n                            }\n                        ]\n                    },\n                    {\n                        \"id\": \"column2\",\n                        \"data_type\": \"varchar\",\n                        \"nullable\": True,\n                        \"unique\": False,\n                        \"required\": False,\n                        \"checks\": [\n                            {\n                                'check_case': 'condition',\n                                'expressions': [\n                                    {\n                                        'command': 'is_in',\n                                        'arg_values': ['a', 'b', 'c']\n                                    },\n                                    {\n                                        'command': 'is_equal_to',\n                                        'subject': ['column1'],\n                                        'arg_values': [1]\n                                    }\n                                ]\n                            }\n                        ],\n                    }\n                \"ids\": [\"column1\"],\n                \"metadata\": {\"description\": \"Example DataFrame schema\"},\n                \"checks\": [\n                    {\n                        'name': 'example_check',\n                        'error_level': 'warning',\n                        'error_msg': 'This is an example check',\n                        'command': 'is_in',\n                        'subject': ['column1', 'column2'],\n                        'arg_values': [1, 2]\n                    }\n                ]\n            }\n\n    Returns:\n        Validator: An instance of the Validator class with the schema\n            created from the provided configuration mapping.\n\n    Raises:\n        Exception: If an error occurs while reading the configuration\n            or creating the schema, and collect_exceptions is False.\n\n    \"\"\"\n    validator = cls()\n    try:\n        validator.df_schema = get_df_schema(config)\n\n    except Exception as err:\n        msg = f'Error reading inputs: {err}'\n        logger.error(msg)\n\n        if not collect_exceptions:\n            raise err\n\n        error_traceback = traceback.format_exc()\n        validator.error_collector.add_errors(\n            ExceptionSchema(\n                error_type=type(err).__name__,\n                error_message=str(err),\n                error_level='critical',\n                error_traceback=error_traceback,\n                error_context='Validator.config_from_mapping',\n                error_source=__name__,\n            )\n        )\n\n    logger.info('DFSchema created successfully')\n    return validator\n</code></pre>"},{"location":"api/#peh_validation_library.validator.validator.Validator.config_from_mapping(config)","title":"<code>config</code>","text":""},{"location":"api/#peh_validation_library.validator.validator.Validator.config_from_mapping(collect_exceptions)","title":"<code>collect_exceptions</code>","text":""},{"location":"api/#peh_validation_library.validator.validator.Validator.config_from_mapping(logger)","title":"<code>logger</code>","text":""},{"location":"api/#peh_validation_library.validator.validator.Validator.validate","title":"validate","text":"<pre><code>validate(\n    dataframe: Mapping[str, list] | pl.DataFrame,\n    lazy_validation: bool = True,\n    collect_exceptions: bool = True,\n    logger: logging.Logger = logger,\n) -&gt; None\n</code></pre> <p>Validates a DataFrame against the defined schema.</p> <p>Parameters:</p> Name Type Description Default <code>Mapping[str, list] | pl.DataFrame</code> <p>The input data as a mapping or a Polars DataFrame.</p> required <code>bool</code> <p>Whether to perform lazy validation. Defaults to True.</p> <code>True</code> <code>bool</code> <p>Whether to collect exceptions during validation. Defaults to True.</p> <code>True</code> <code>logging.Logger</code> <p>Logger instance for logging. Defaults to the module logger.</p> <code>logger</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If an error occurs during validation and collect_exceptions is False.</p> Source code in <code>src/peh_validation_library/validator/validator.py</code> <pre><code>def validate(\n    self,\n    dataframe: Mapping[str, list] | pl.DataFrame,\n    lazy_validation: bool = True,\n    collect_exceptions: bool = True,\n    logger: logging.Logger = logger,\n) -&gt; None:\n    \"\"\"Validates a DataFrame against the defined schema.\n\n    Args:\n        dataframe (Mapping[str, list] | pl.DataFrame): The input data\n            as a mapping or a Polars DataFrame.\n        lazy_validation (bool, optional): Whether to perform lazy validation.\n            Defaults to True.\n        collect_exceptions (bool, optional): Whether to collect exceptions\n            during validation. Defaults to True.\n        logger (logging.Logger, optional): Logger instance for logging.\n            Defaults to the module logger.\n\n    Raises:\n        Exception: If an error occurs during validation and\n            collect_exceptions is False.\n\n    \"\"\"  # noqa: E501\n    logger.info('Starting DataFrame validation')\n    if isinstance(dataframe, Mapping):\n        dataframe = self.convert_mapping_to_dataframe(\n            dataframe=dataframe,\n            collect_exceptions=collect_exceptions,\n            logger=logger,\n        )\n\n    try:\n        logger.info(f'Building DataFrame schema {self.df_schema.name =}')\n        df_schema = self.df_schema.build()\n    except Exception as err:\n        msg = f'Error building dataframe schema: {err}'\n        logger.error(msg)\n\n        if not collect_exceptions:\n            raise err\n\n        error_traceback = traceback.format_exc()\n        self.error_collector.add_errors(\n            ExceptionSchema(\n                error_type=type(err).__name__,\n                error_message=str(err),\n                error_level='critical',\n                error_traceback=error_traceback,\n                error_context='Validator.validate',\n                error_source=__name__,\n            )\n        )\n        return\n\n    try:\n        logger.info('Casting DataFrame Types')\n        dataframe = dataframe.cast({\n            col.id: validation_type_mapper[col.data_type]\n            for col in self.df_schema.columns\n            if col.id in dataframe.columns\n        })\n\n    except Exception as err:\n        msg = f'Error casting dataframe types: {err}'\n        logger.error(msg)\n\n        if not collect_exceptions:\n            raise err\n\n        error_traceback = traceback.format_exc()\n        self.error_collector.add_errors(\n            ExceptionSchema(\n                error_type=type(err).__name__,\n                error_message=str(err),\n                error_level='critical',\n                error_traceback=error_traceback,\n                error_context='Validator.validate',\n                error_source=__name__,\n            )\n        )\n        return\n\n    try:\n        logger.info('Starting DataFrame validation')\n        dataframe.pipe(df_schema.validate, lazy=lazy_validation)\n\n    except (pa.errors.SchemaErrors, pa.errors.SchemaError) as err:\n        if not collect_exceptions:\n            raise err\n\n        logger.info('Collecting validation errors')\n        self.error_collector.add_errors(err)\n\n    # Pandera not implemented for polars some lazy validation.\n    # Run in again in eager mode to catch the error.\n    # This is a workaround for the issue.\n    except NotImplementedError:\n        try:\n            logger.warning('Trying eager validation')\n            dataframe.pipe(df_schema.validate)\n\n        except pa.errors.SchemaError as err:\n            if not collect_exceptions:\n                raise err\n\n            logger.info('Collecting eager validation errors')\n            self.error_collector.add_errors(err)\n\n    except Exception as err:\n        msg = f'Error validating dataframe: {err}'\n        logger.error(msg)\n\n        if not collect_exceptions:\n            raise err\n\n        error_traceback = traceback.format_exc()\n        self.error_collector.add_errors(\n            ExceptionSchema(\n                error_type=type(err).__name__,\n                error_message=str(err),\n                error_level='critical',\n                error_traceback=error_traceback,\n                error_context='Validator.validate',\n                error_source=__name__,\n            )\n        )\n\n    logger.info('DataFrame validation completed')\n</code></pre>"},{"location":"api/#peh_validation_library.validator.validator.Validator.validate(dataframe)","title":"<code>dataframe</code>","text":""},{"location":"api/#peh_validation_library.validator.validator.Validator.validate(lazy_validation)","title":"<code>lazy_validation</code>","text":""},{"location":"api/#peh_validation_library.validator.validator.Validator.validate(collect_exceptions)","title":"<code>collect_exceptions</code>","text":""},{"location":"api/#peh_validation_library.validator.validator.Validator.validate(logger)","title":"<code>logger</code>","text":""},{"location":"api/#peh_validation_library.core.utils.enums.CheckCases","title":"CheckCases","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing different types of check cases.</p> Source code in <code>src/peh_validation_library/core/utils/enums.py</code> <pre><code>class CheckCases(Enum):\n    \"\"\"Enum representing different types of check cases.\"\"\"\n\n    CONDITION = 'condition'\n    CONJUNCTION = 'conjunction'\n    DISJUNCTION = 'disjunction'\n</code></pre>"},{"location":"api/#peh_validation_library.core.utils.enums.ErrorLevel","title":"ErrorLevel","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing different levels of error severity.</p> Source code in <code>src/peh_validation_library/core/utils/enums.py</code> <pre><code>class ErrorLevel(Enum):\n    \"\"\"Enum representing different levels of error severity.\"\"\"\n\n    WARNING = 'warning'\n    ERROR = 'error'\n    CRITICAL = 'critical'\n</code></pre>"},{"location":"api/#peh_validation_library.core.utils.enums.ValidationType","title":"ValidationType","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing different validation types for DataFrame columns.</p> Source code in <code>src/peh_validation_library/core/utils/enums.py</code> <pre><code>class ValidationType(Enum):\n    \"\"\"Enum representing different validation types for DataFrame columns.\"\"\"\n\n    DATE = 'date'\n    DATETIME = 'datetime'\n    BOOL = 'boolean'\n    FLOAT = 'decimal'\n    INT = 'integer'\n    STR = 'varchar'\n    CAT = 'categorical'\n</code></pre>"},{"location":"api/#peh_validation_library.error_report.error_collector.ErrorCollector","title":"ErrorCollector  <code>cached</code>","text":"<p>ErrorCollector class for collecting errors during validation.</p> Source code in <code>src/peh_validation_library/error_report/error_collector.py</code> <pre><code>@cache\nclass ErrorCollector:\n    \"\"\"ErrorCollector class for collecting errors during validation.\"\"\"\n\n    COUNTER = 0\n\n    def __init__(self):\n        self.__errors = []\n        self.__exceptions = []\n\n    def add_errors(\n        self,\n        error: ExceptionSchema\n        | pa.errors.SchemaError\n        | pa.errors.SchemaErrors,  # noqa: E501\n    ) -&gt; None:\n        \"\"\"Adds errors to the collector.\n\n        Args:\n            error (ExceptionSchema | pa.errors.SchemaError | pa.errors.SchemaErrors): The error to add.\n\n        Returns:\n            None\n\n        \"\"\"  # noqa: E501\n        if getattr(error, 'error_traceback', None):\n            self.__exceptions.append(error)\n            return\n\n        errors = []\n\n        if getattr(error, 'schema_errors', None):\n            idx_columns = error.schema.unique\n            for err in error.schema_errors:\n                column_names, row_ids = from_schema_error(err)\n\n                if not isinstance(err.check, str):\n                    errors.append(\n                        ErrorSchema(\n                            column_names=column_names,\n                            row_ids=row_ids,\n                            idx_columns=idx_columns,\n                            level=err.check.name,\n                            message=err.check.error,\n                            title=err.check.title,\n                        )\n                    )\n                else:\n                    errors.append(\n                        ErrorSchema(\n                            column_names=column_names,\n                            row_ids=row_ids,\n                            idx_columns=idx_columns,\n                            level='error',\n                            message=err.check,\n                            title=err.check,\n                        )\n                    )\n\n        else:\n            column_names, row_ids = from_schema_error(err)\n            errors.append(\n                ErrorSchema(\n                    column_names=column_names,\n                    row_ids=row_ids,\n                    idx_columns=error.schema.unique,\n                    level=error.schema.level,\n                    message=error.schema.message,\n                    title=error.schema.title,\n                )\n            )\n\n        if len(errors) &gt; 0:\n            self.__errors.append(\n                ErrorReportSchema(\n                    name=error.schema.name,\n                    errors=errors,\n                    total_errors=len(errors),\n                    id=self.COUNTER,\n                )\n            )\n            self.COUNTER += len(errors)\n\n    def get_errors(self) -&gt; ErrorCollectorSchema:\n        \"\"\"Returns the collected errors and exceptions.\n\n        Returns:\n            ErrorCollectorSchema: A schema containing the collected errors and exceptions.\n\n        \"\"\"  # noqa: E501\n        return ErrorCollectorSchema(\n            error_reports=self.__errors, exceptions=self.__exceptions\n        )\n\n    def clear_errors(self) -&gt; None:\n        \"\"\"Clears the collected errors and exceptions.\"\"\"\n        self.__errors.clear()\n        self.__exceptions.clear()\n        self.COUNTER = 0\n</code></pre>"},{"location":"api/#peh_validation_library.error_report.error_collector.ErrorCollector.add_errors","title":"add_errors","text":"<pre><code>add_errors(\n    error: ExceptionSchema\n    | pa.errors.SchemaError\n    | pa.errors.SchemaErrors,\n) -&gt; None\n</code></pre> <p>Adds errors to the collector.</p> <p>Parameters:</p> Name Type Description Default <code>ExceptionSchema | pa.errors.SchemaError | pa.errors.SchemaErrors</code> <p>The error to add.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/peh_validation_library/error_report/error_collector.py</code> <pre><code>def add_errors(\n    self,\n    error: ExceptionSchema\n    | pa.errors.SchemaError\n    | pa.errors.SchemaErrors,  # noqa: E501\n) -&gt; None:\n    \"\"\"Adds errors to the collector.\n\n    Args:\n        error (ExceptionSchema | pa.errors.SchemaError | pa.errors.SchemaErrors): The error to add.\n\n    Returns:\n        None\n\n    \"\"\"  # noqa: E501\n    if getattr(error, 'error_traceback', None):\n        self.__exceptions.append(error)\n        return\n\n    errors = []\n\n    if getattr(error, 'schema_errors', None):\n        idx_columns = error.schema.unique\n        for err in error.schema_errors:\n            column_names, row_ids = from_schema_error(err)\n\n            if not isinstance(err.check, str):\n                errors.append(\n                    ErrorSchema(\n                        column_names=column_names,\n                        row_ids=row_ids,\n                        idx_columns=idx_columns,\n                        level=err.check.name,\n                        message=err.check.error,\n                        title=err.check.title,\n                    )\n                )\n            else:\n                errors.append(\n                    ErrorSchema(\n                        column_names=column_names,\n                        row_ids=row_ids,\n                        idx_columns=idx_columns,\n                        level='error',\n                        message=err.check,\n                        title=err.check,\n                    )\n                )\n\n    else:\n        column_names, row_ids = from_schema_error(err)\n        errors.append(\n            ErrorSchema(\n                column_names=column_names,\n                row_ids=row_ids,\n                idx_columns=error.schema.unique,\n                level=error.schema.level,\n                message=error.schema.message,\n                title=error.schema.title,\n            )\n        )\n\n    if len(errors) &gt; 0:\n        self.__errors.append(\n            ErrorReportSchema(\n                name=error.schema.name,\n                errors=errors,\n                total_errors=len(errors),\n                id=self.COUNTER,\n            )\n        )\n        self.COUNTER += len(errors)\n</code></pre>"},{"location":"api/#peh_validation_library.error_report.error_collector.ErrorCollector.add_errors(error)","title":"<code>error</code>","text":""},{"location":"api/#peh_validation_library.error_report.error_collector.ErrorCollector.clear_errors","title":"clear_errors","text":"<pre><code>clear_errors() -&gt; None\n</code></pre> <p>Clears the collected errors and exceptions.</p> Source code in <code>src/peh_validation_library/error_report/error_collector.py</code> <pre><code>def clear_errors(self) -&gt; None:\n    \"\"\"Clears the collected errors and exceptions.\"\"\"\n    self.__errors.clear()\n    self.__exceptions.clear()\n    self.COUNTER = 0\n</code></pre>"},{"location":"api/#peh_validation_library.error_report.error_collector.ErrorCollector.get_errors","title":"get_errors","text":"<pre><code>get_errors() -&gt; ErrorCollectorSchema\n</code></pre> <p>Returns the collected errors and exceptions.</p> <p>Returns:</p> Name Type Description <code>ErrorCollectorSchema</code> <code>ErrorCollectorSchema</code> <p>A schema containing the collected errors and exceptions.</p> Source code in <code>src/peh_validation_library/error_report/error_collector.py</code> <pre><code>def get_errors(self) -&gt; ErrorCollectorSchema:\n    \"\"\"Returns the collected errors and exceptions.\n\n    Returns:\n        ErrorCollectorSchema: A schema containing the collected errors and exceptions.\n\n    \"\"\"  # noqa: E501\n    return ErrorCollectorSchema(\n        error_reports=self.__errors, exceptions=self.__exceptions\n    )\n</code></pre>"},{"location":"api/#peh_validation_library.error_report.error_schemas.ErrorCollectorSchema","title":"ErrorCollectorSchema","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema for collecting errors and exceptions during validation.</p> <p>Attributes:</p> Name Type Description <code>error_reports</code> <code>list[ErrorReportSchema]</code> <p>List of error reports.</p> <code>exceptions</code> <code>list[ExceptionSchema]</code> <p>List of exceptions that occurred during validation.</p> Source code in <code>src/peh_validation_library/error_report/error_schemas.py</code> <pre><code>class ErrorCollectorSchema(BaseModel):\n    \"\"\"Schema for collecting errors and exceptions during validation.\n\n    Attributes:\n        error_reports (list[ErrorReportSchema]): List of error reports.\n        exceptions (list[ExceptionSchema]): List of exceptions that occurred during validation.\n\n    \"\"\"  # noqa: E501\n\n    error_reports: list[ErrorReportSchema] = []\n    exceptions: list[ExceptionSchema] = []\n</code></pre>"},{"location":"api/#peh_validation_library.error_report.error_schemas.ErrorReportSchema","title":"ErrorReportSchema","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema for error reports generated during validation.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the error report.</p> <code>errors</code> <code>list[ErrorSchema]</code> <p>List of errors found in the DataFrame.</p> <code>total_errors</code> <code>int</code> <p>Total number of errors in the report.</p> <code>id</code> <code>int</code> <p>Unique identifier for the error report.</p> Source code in <code>src/peh_validation_library/error_report/error_schemas.py</code> <pre><code>class ErrorReportSchema(BaseModel):\n    \"\"\"Schema for error reports generated during validation.\n\n    Attributes:\n        name (str): Name of the error report.\n        errors (list[ErrorSchema]): List of errors found in the DataFrame.\n        total_errors (int): Total number of errors in the report.\n        id (int): Unique identifier for the error report.\n\n    \"\"\"\n\n    name: str\n    errors: list[ErrorSchema]\n    total_errors: int\n    id: int\n</code></pre>"},{"location":"api/#peh_validation_library.error_report.error_schemas.ErrorSchema","title":"ErrorSchema","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema for errors that occur during DataFrame validation.</p> <p>Attributes:</p> Name Type Description <code>column_names</code> <code>list[str] | str</code> <p>Names of the columns where the error occurred.</p> <code>row_ids</code> <code>list[int]</code> <p>IDs of the rows where the error occurred.</p> <code>idx_columns</code> <code>list[str]</code> <p>Index columns used for identifying errors.</p> <code>level</code> <code>str</code> <p>Level of the error, e.g., 'error', 'warning'.</p> <code>message</code> <code>str</code> <p>Message describing the error.</p> <code>title</code> <code>str</code> <p>Title of the error.</p> Source code in <code>src/peh_validation_library/error_report/error_schemas.py</code> <pre><code>class ErrorSchema(BaseModel):\n    \"\"\"Schema for errors that occur during DataFrame validation.\n\n    Attributes:\n        column_names (list[str] | str): Names of the columns where the error occurred.\n        row_ids (list[int]): IDs of the rows where the error occurred.\n        idx_columns (list[str]): Index columns used for identifying errors.\n        level (str): Level of the error, e.g., 'error', 'warning'.\n        message (str): Message describing the error.\n        title (str): Title of the error.\n\n    \"\"\"  # noqa: E501\n\n    column_names: list[str] | str\n    row_ids: list[int]\n    idx_columns: list[str]\n    level: str\n    message: str\n    title: str\n</code></pre>"},{"location":"api/#peh_validation_library.error_report.error_schemas.ExceptionSchema","title":"ExceptionSchema","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema for exceptions that occur during validation.</p> <p>Attributes:</p> Name Type Description <code>error_type</code> <code>str</code> <p>Type of the error.</p> <code>error_message</code> <code>str</code> <p>Message describing the error.</p> <code>error_level</code> <code>ErrorLevel</code> <p>Level of the error.</p> <code>error_traceback</code> <code>str</code> <p>Traceback of the error.</p> <code>error_context</code> <code>str | None</code> <p>Context of the error, if available.</p> <code>error_source</code> <code>str | None</code> <p>Source of the error, if available.</p> Source code in <code>src/peh_validation_library/error_report/error_schemas.py</code> <pre><code>class ExceptionSchema(BaseModel):\n    \"\"\"Schema for exceptions that occur during validation.\n\n    Attributes:\n        error_type (str): Type of the error.\n        error_message (str): Message describing the error.\n        error_level (ErrorLevel): Level of the error.\n        error_traceback (str): Traceback of the error.\n        error_context (str | None): Context of the error, if available.\n        error_source (str | None): Source of the error, if available.\n\n    \"\"\"\n\n    error_type: str\n    error_message: str\n    error_level: ErrorLevel\n    error_traceback: str\n    error_context: str | None = None\n    error_source: str | None = None\n</code></pre>"}]}